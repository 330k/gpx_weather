<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<title>GPX 天候情報</title>
<meta property="og:title" content="GPX 天候情報" />
<meta property="og:description" content="Poor Man's Epic Ride Weather" />
<meta property="og:type" content="website" />
<meta property="og:url" content="hhttps://330k.github.io/gpx_weather/gpx_weather.html" />
<meta property="og:image" content="https://330k.github.io/gpx_weather/icons/icon_256x256.png"/>
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="application-name" content="GPX 天候情報">
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-capable" content="yes">
<link rel="manifest" href="manifest.json">
<link rel="favicon" type="image/png"  href="icons/icon_256x256.png">
<link rel="apple-touch-icon" sizes="240x240" href="icons/icon_240x240.png">
<script defer src="https://maps.google.com/maps/api/js?key=AIzaSyA_aFkNjCuqBNETe8bxBk8_cnRQtQzdOG8&amp;callback=initMap"></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js" integrity="sha512-ElRFoEQdI5Ht6kZvyzXhYG9NqjtkmlkfYk0wr6wHxU9JEHakS7UJZNeml5ALk+8IKlU6jDgMabC3vkumRokgJA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.4/moment-with-locales.min.js" integrity="sha512-42PE0rd+wZ2hNXftlM78BSehIGzezNeQuzihiBCvUEB3CVxHvsShF86wBWwQORNxNINlBPuq7rG4WWhNiTVHFg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script defer src="https://cdn.jsdelivr.net/npm/chartjs-adapter-moment@1.0.0"></script>
<script>
if ("serviceWorker" in navigator) {
  window.addEventListener("load", function() {
    navigator.serviceWorker.register("sw.js").then(function(registration) {
      //Service Worker(sw.js)が登録できたら特に何もしない。
    }, function(err) {
      //Service Worker(sw.js)の登録が失敗した場合はブラウザにログを出す。
      console.log("ServiceWorker registration failed: ", err);
    });
  });
}
</script>
<script async src="https://www.google-analytics.com/analytics.js"></script>
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
  window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
  ga("create", "UA-5655726-3", "auto");
  
  ga("send", "pageview");
}
</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-L5FSJ397HF"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag("js", new Date());

  gtag("config", "G-L5FSJ397HF");
</script>
<script>
"use strict";
/* Copyright 2022 Kei Misawa All Rights Reserved */

const googlemap = {
  map: null,
  lines: [],
  dist_marker: null,
  weather_markers: []
};
const gpx_data = [];
const lcache = new LayeredCache("gpx-weather", function(response){
  if(response.ok){
    return response.json();
  }else{
    return null;
  }
}, 1000, 1 * 3600 * 1000);
const weather_data = new WeatherData();
const weather_points = [];
const charts = {
  temperature: null,
  wind: null,
  precipitation: null
};

/**
 * Hubeny測地線距離計算式(標準)
 * https://amano-tec.com/apps/paceruler.html
 * @param {number} lat1
 * @param {number} lon1
 * @param {number} lat2
 * @param {number} lon2
 * @return {number} distance [m]
 */
function hubeny(lat1, lon1, lat2, lon2){
  "use strict";
  const a = 6378137.0;
  const f = 1 / 298.257223563;
  const e2 = f * (2 - f);
  const e2p = e2 / (1 - e2);
  const degree = Math.PI / 180.0;
  const sin = Math.sin;
  const cos = Math.cos;
  const tan = Math.tan;
  const sqrt = Math.sqrt;
  
  const latdiff = (lat1 - lat2) * degree;
  const londiff = (((lon1 - lon2 + 180) % 360) - 180) * degree;
  const latave = 0.5 * (lat1 + lat2) * degree;
  const sinlatave = sin(latave);
  const coslatave = cos(latave);
  const w2 = 1.0 - sinlatave * sinlatave * e2;
  const n = a / sqrt(w2);
  const eta2 = e2p * coslatave * coslatave;
  const eta4 = eta2 * eta2;
  const eta6 = eta2 * eta4;
  const t = tan(latave);
  const t2 = t * t;
  const t4 = t2 * t2;
  const t6 = t2 * t4;
  const latdiff2 = latdiff * latdiff;
  const latdiff3 = latdiff * latdiff2;
  const latdiff4 = latdiff * latdiff3;
  const latdiff5 = latdiff * latdiff4;
  const latdiff6 = latdiff * latdiff5;
  const londiff2 = londiff * londiff;
  const londiff3 = londiff * londiff2;
  const londiff4 = londiff * londiff3;
  const londiff5 = londiff * londiff4;
  const londiff6 = londiff * londiff5;
  const londiff7 = londiff * londiff6;
  const coslatave2 = coslatave * coslatave;
  const coslatave3 = coslatave * coslatave2;
  const coslatave4 = coslatave * coslatave3;
  const coslatave5 = coslatave * coslatave4;
  const coslatave6 = coslatave * coslatave5;
  const coslatave7 = coslatave * coslatave6;

  const ss = n * coslatave * londiff
    + (n * coslatave  /      24) * (1 - eta2 + eta4 - eta6 - 9 * t2 * eta2 + 18 * t2 * eta4 - 27 * t2 * eta6) * latdiff2 * londiff
    + (n * coslatave3 /      24) * (-t2) * londiff3
    + (n * coslatave  /    5760) * (7 + 10 * eta2 - 27 * eta4 - 54 * t2 * eta2 - 642 * t2 * eta4 + 675 * t2 * eta6) * latdiff4 * londiff
    + (n * coslatave3 /    5760) * (-16 - 70 * t2 - 158 * t2 * eta2 + 158 * t2 * eta4 + 90 * t4 * eta2 - 180 * t4 * eta4) * latdiff2 * londiff3
    + (n * coslatave5 /    5760) * (-24 * t2 + 3 * t4 - 27 * t2 * eta2) * londiff5
    + (n * coslatave  / 1935360) * 62 * latdiff6 * londiff
    + (n * coslatave3 / 1935360) * (-416 - 2954 * t2) * latdiff4 * londiff3
    + (n * coslatave5 / 1935360) * (-192 - 1680 * t2 + 2652 * t4) * latdiff2 * londiff5
    + (n * coslatave7 / 1935360) * (-816 * t2 + 528 * t4 - 6 * t2) * londiff7;
  const sc = n / (1 + eta2) * latdiff
    + (n              /      24) * (3 * eta2 - 6 * eta4 + 9 * eta6 - 3 * t2 * eta2 + 21 * t2 * eta4 - 54 * t2 * eta6) * latdiff3
    + (n * coslatave2 /      24) * (-2 - 3 * t2 + 3 * t2 * eta2 - 3 * t2 * eta4 + 3 * t2 * eta6) * latdiff * londiff2
    + (n              /    5760) * (-36 * eta2 + 207 * eta4 + 36 * t2 * eta2 - 1062 * t2 * eta4 + 135 * t4 * eta4) * latdiff5
    + (n * coslatave2 /    5760) * (-16 - 60 * t2 + 4 * eta2 - 4 * eta4 + 102 * t2 * eta2 + 48 * t2 * eta4 + 90 * t4 * eta2 - 630 * t4 * eta4) * latdiff3 * londiff2
    + (n * coslatave4 /    5760) * (-8 - 20 * t2 + 15 * t4 - 8 * eta2 + 96 * t2 * eta2 - 15 * t4 * eta2 + 15 * t4 * eta4) * latdiff * londiff4
    + (n * coslatave2 / 1935360) * (-192 - 2016 * t2) * latdiff5 * londiff2
    + (n * coslatave4 / 1935360) * (256 + 784 * t2 + 4200 * t4) * latdiff3 * londiff4
    + (n * coslatave6 / 1935360) * (-64 - 224 * t2 + 1148 * t4 - 42 * t6) * latdiff * londiff6;
  return sqrt(ss * ss + sc * sc);
}

/**
 * XMLファイルを読み込むPromiseを返す
 * @param {string} file 読み込むファイル
 * @return {XMLDocument} 読み込んだ結果をXMLObjectを返すPromise
 */
function readXML(file){
  return new Promise(function(resolve, reject){
    try{
      const reader = new FileReader();
      const parser = new DOMParser();

      reader.onload = function(){
        resolve(parser.parseFromString(reader.result, "text/xml"));
      };
      reader.readAsText(file, "utf-8");
      
    }catch(e){
      reject(e);
    }
  });
}

/**
 * GPXファイルを解析して、緯度、経度、距離の配列にする
 * @param {XMLDocument} xml
 * @param {string} name
 * @return {[{lat:number,lng:number,dist:number}]}
 */
function parseGPX(xml, name){
  const trkpts = xml.querySelectorAll("trkpt");
  if(trkpts.length === 0){
    return;
  }

  const coords = [];
  let min_lat = Number.MAX_VALUE;
  let max_lat = -Number.MAX_VALUE;
  let min_lng = Number.MAX_VALUE;
  let max_lng = -Number.MAX_VALUE;

  let d = 0.0;
  for(let i = 0; i < trkpts.length; i++){
    const lat = trkpts[i].getAttribute("lat") - 0;
    const lng = trkpts[i].getAttribute("lon") - 0;
    const xy = latlng2MercatorXY(lat, lng);
    
    if(i > 0){
      d += hubeny(coords[coords.length - 1].lat, coords[coords.length - 1].lng, lat, lng);
    }
    coords.push({
      lat: lat,
      lng: lng,
      dist: d,
      X: xy.X,
      Y: xy.Y
    });
    
    if(lat < min_lat) min_lat = lat;
    if(lat > max_lat) max_lat = lat;
    if(lng < min_lng) min_lng = lng;
    if(lng > max_lng) max_lng = lng;
  }
  
  return {
    name: name,
    coords: coords,
    min_lat: min_lat,
    max_lat: max_lat,
    min_lng: min_lng,
    max_lng: max_lng
  };
}
/**
 * 緯度経度からメルカトル図法座標(X, Y)に変換
 * @param {number} lat 緯度
 * @param {number} lng 経度
 * @return {{X:number,Y:number}}
 */
function latlng2MercatorXY(lat, lng){
  const DEGREE = Math.PI / 180;
  
  return {
    X: lng * DEGREE,
    Y: Math.asinh(Math.tanh(lat * DEGREE))
  };
}

class RDPTree{constructor(t,e,s=!1){this.coords=t,this.dist_func=e,this.balanced=s,this.rdptree=this._createRDPTree(0,t.length-1)}searchNearest(t,e=Number.MAX_VALUE){return this._searchNearest(this.rdptree,t,e)}_createRDPTree(t,e){let s=-Number.MAX_VALUE,r=-1;for(let i=t+1;i<=e-1;i++){const a=this.dist_func(this.coords[t],this.coords[e],this.coords[i]).distance;a>s&&(s=a,r=i)}return this.balanced&&(r=Math.floor(.5*(t+e))),s>0?{start:t,end:e,max_distance:s,max_index:r,left:this._createRDPTree(t,r),right:this._createRDPTree(r,e)}:{start:t,end:e,max_distance:0,max_index:-1,left:null,right:null}}_searchNearest(t,e,s){if(0===t.max_distance)return{start:t.start,end:t.end,...this.dist_func(this.coords[t.start],this.coords[t.end],e)};const r=this.dist_func(this.coords[t.start],this.coords[t.max_index],e).distance,i=this.dist_func(this.coords[t.max_index],this.coords[t.end],e).distance,a=r-t.left.max_distance>s,n=i-t.right.max_distance>s;if(a&&n)return{start:null,end:null,distance:Number.MAX_VALUE};if(a)return this._searchNearest(t.right,e,s);if(n)return this._searchNearest(t.left,e,s);let c,d,h,o;r<i?(h=t.left,c=r,o=t.right,d=i):(h=t.right,c=i,o=t.left,d=r);const _=this._searchNearest(h,e,s);if(0===_.distance)return _;const l=Math.min(s,_.distance);if(d-o.max_distance>l)return _;const u=this._searchNearest(o,e,l);return _.distance<u.distance?_:u}}
/**
 * ルートをGoogle Mapsに表示
 * @param {[{lat:number,lng:number,dist:number}]} coords
 * @param {string} name
 * @param {Object} options
 * @param {boolean} showInfo
 * @return {void}
 */
function drawPolyline(coords, name = "", options = {strokeColor: "#f00", strokeOpacity: 1.0, strokeWeight: 2.0, zIndex: 1}, showInfo = true){
  // 表示用のPolyline
  const line_display = new google.maps.Polyline({
    path: coords,
    geodesic: true,
    ...options
  });
  googlemap.lines.push(line_display);
  line_display.setMap(googlemap.map);
  
  if(showInfo){
    // マウスイベントを拾うための透明なPolyline
    const line_transparent = new google.maps.Polyline({
      path: coords,
      geodesic: true,
      strokeColor: "#000",
      strokeOpacity: 0,
      strokeWeight: 30,
      zIndex: 9999
    });
    const rdptree = new RDPTree(coords, (a, b, p) => {
      const ax = a.X, ay = a.Y;
      const bx = b.X, by = b.Y;
      const px = p.X, py = p.Y;
      
      let t = ((ax - bx) * (ax - px) + (ay - by) * (ay - py)) / ((ax - bx) * (ax - bx) + (ay - by) * (ay - by));
      
      if(t > 1){
        t = 1;
      }else if(t > 0){
        
      }else{
        t = 0;
      }
      
      const x = ax - (ax - bx) * t;
      const y = ay - (ay - by) * t;
      
      return {
        "distance": Math.sqrt((x - px) * (x - px) + (y - py) * (y - py)),
        "x": x,
        "y": y,
        "t": t
      };
    });

    const dist_info = document.getElementById("dist_info");

    line_transparent.addListener("mousemove", function(evt){
      // GPXトラック上にマウスが来たときは距離を表示する
      const lat = evt.latLng.lat();
      const lng = evt.latLng.lng();
      const xy = latlng2MercatorXY(lat, lng);
      
      const nearest = rdptree.searchNearest(xy);
      let min_dist = Number.MAX_VALUE;
      let min_index = -1;
      for(let i = nearest.start; i <= nearest.end; i++){
        const dist = hubeny(lat, lng, coords[i].lat, coords[i].lng);
        if(dist < min_dist){
          min_dist = dist;
          min_index = i;
        }
      }
      
      if(googlemap.dist_marker){
        googlemap.dist_marker.setPosition(coords[min_index]);

      }else{
        googlemap.dist_marker = new google.maps.Marker({
          position: coords[min_index],
          icon: {
            path: google.maps.SymbolPath.CIRCLE,
            scale: 0.5 * options.strokeWeight + 4,
            fillColor: options.strokeColor,
            fillOpacity: 0.5,
            strokeColor: options.strokeColor,
            strokeOpacity: 1,
            strokeWeight: 1,
            zIndex: 100
          },
          map: googlemap.map
        });
      }

      dist_info.innerHTML = name + ": " + (0.001 * coords[min_index].dist).toFixed(1) + " km";
      dist_info.style.display = "block";
      dist_info.style.left = (evt.domEvent.pageX - dist_info.clientWidth * 0.5) + "px";
      dist_info.style.top = (evt.domEvent.pageY - dist_info.clientHeight - 20) + "px";

    });
    line_transparent.addListener("mouseout", function(evt){
      dist_info.style.display = "none";
      if(googlemap.dist_marker){
        googlemap.dist_marker.setMap(null);
        googlemap.dist_marker = null;
      }
    });
    
    googlemap.lines.push(line_transparent);
    line_transparent.setMap(googlemap.map);
  }
}

/**
 * Google Mapsの表示範囲を調整
 */
function fitBounds(){
  if(gpx_data.length > 0){
    let min_lat = Number.MAX_VALUE;
    let min_lng = Number.MAX_VALUE;
    let max_lat = -Number.MAX_VALUE;
    let max_lng = -Number.MAX_VALUE;
    for(let r of gpx_data){
      if(r.min_lat < min_lat) min_lat = r.min_lat;
      if(r.min_lng < min_lng) min_lng = r.min_lng;
      if(r.max_lat > max_lat) max_lat = r.max_lat;
      if(r.max_lng > max_lng) max_lng = r.max_lng;
    }
    googlemap.map.fitBounds({
      south: min_lat,
      west: min_lng,
      north: max_lat,
      east: max_lng
    });
  }
}

/**
 * ルートを表示する
 */
function showRoutes(){
  //const colors = ["#3f3d9a", "#9a3d71", "#9a8c3d", "#3d9a56", "#3d5a9a", "#9a3d90", "#9a6d3d", "#439a3d", "#3d799a", "#843d9a", "#9a4e3d", "#629a3d"];
  const colors = ["#ff0000"];
  
  googlemap.lines.map((e) => {e.setMap(null);});
  googlemap.lines.length = 0;
  
  for(let i = 0; i < gpx_data.length; i++){
    drawPolyline(gpx_data[i].coords, gpx_data[i].name, {
      strokeColor: colors[i % colors.length],
      strokeOpacity: 1.0,
      strokeWeight: 2,
      zIndex: 1
    }, true);
  }
}

/**
 * 気象予報データを管理する
 */
function WeatherData(){
  this._weather_data = {};
  
  // 緯度方向は1/20度、経度方向は1/16度
  const getLatLngCode = (lat, lng) => Math.round(lat * 20) + "," + Math.round(lng * 16);
  
  /**
   * 気象予報データをAPIで一括取得する
   * @params {[{lat:number,lng:number}]} coords 取得したい緯度経度の配列
   * @return {Promise} すべて取得し終えた時に解決されるPromise
   */
  this.fetchWeatherData = function(coords){
    // timeはGMTのgetTimeで管理する
    
    const now = new Date();
    const start_date = new Date(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate() - 1);
    const end_date = new Date(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate() + 8);
    const start_date_str = start_date.getFullYear() + "-" + ("0" + (start_date.getMonth() + 1)).slice(-2) + "-" + ("0" + start_date.getDate()).slice(-2);
    const end_date_str = end_date.getFullYear() + "-" + ("0" + (end_date.getMonth() + 1)).slice(-2) + "-" + ("0" + end_date.getDate()).slice(-2);
    
    const latlngs = {};  // APIに問い合わせる緯度経度
    
    for(const c of coords){
      const latlng_code = getLatLngCode(c.lat, c.lng);
      
      // 未取得かつ重複していない場合にのみAPI呼び出しリストに追加する
      if((this._weather_data[latlng_code] === void 0) && (latlngs[latlng_code] === void 0)){
        latlngs[latlng_code] = c;
      }
    }
    
    // APIを呼び出して気象データを取得
    const promises = [];
    
    for(const p of Object.values(latlngs)){
      promises.push(new Promise((resolve, reject) => {
        const url = `https://api.open-meteo.com/v1/forecast?latitude=${p.lat}&longitude=${p.lng}&hourly=temperature_2m,precipitation,weathercode,windspeed_10m,winddirection_10m,windgusts_10m,cloudcover&windspeed_unit=ms&start_date=${start_date_str}&end_date=${end_date_str}`;
        /*fetch(url).then((response) => {
          return response.json();
        }).then((json) => {*/
        lcache.fetch(url).then((json) => {
          //console.log(json);
          const latlng_code = getLatLngCode(p.lat, p.lng);
          this._weather_data[latlng_code] = [];
          
          for(let i = 0; i < json.hourly.time.length; i++){
            if(json.hourly.temperature_2m[i] !== null){
              this._weather_data[latlng_code].push({
                time: (new Date(json.hourly.time[i] + "Z")).getTime(),
                temperature_2m: json.hourly.temperature_2m[i],
                precipitation: json.hourly.precipitation[i],
                weathercode: json.hourly.weathercode[i],
                windspeed_10m: json.hourly.windspeed_10m[i],
                winddirection_10m: json.hourly.winddirection_10m[i],
                windgusts_10m: json.hourly.windgusts_10m[i],
                cloudcover: json.hourly.cloudcover[i]
              });
            }
          }
          
          resolve();
        });
      }));
    }
    
    return Promise.all(promises);
  }
  
  /**
   * 取得済みの天気予報データから、指定した緯度経度、指定した時刻(に最も近い)のものを返す
   * @param {{lat:number,lng:number}} latlng
   * @param {number} time (getTimeでの値)
   * @return {{time:number,temperature_2m:number}}
   */
  this.getWeatherData = function(latlng, time){
    const latlng_code = getLatLngCode(latlng.lat, latlng.lng);
    
    if(this._weather_data[latlng_code]){
      const times = this._weather_data[latlng_code].map(e => e.time);
      
      let result = null;
      let min = Number.MAX_VALUE;
      
      for(const d of this._weather_data[latlng_code]){
        const diff = Math.abs(d.time - time);
        if((diff < 3600000) && (diff < min)){
          result = d;
          min = diff;
        }
      }
      
      return result;
    }else{
      console.error({latlng, latlng_code, time});
      
      return null;
      
    }
  }
  
  /**
   * 取得済みの天気予報データから、指定した緯度経度でデータがある時刻の配列を返す
   * @param {{lat:number,lng:number}} latlng
   * @return {[number]}
   */
  this.listWeatherDateTime = function(latlng){
    const latlng_code = getLatLngCode(latlng.lat, latlng.lng);
    
    return this._weather_data[latlng_code].map(e => e.time);
  }
  
  return this;
}

/**
 * フォームの選択状態から目標速度を得る
 */
function getTargetSpeed(){
  if(document.getElementById("radio_speed").checked){
    return document.getElementById("input_speed").value - 0;
  }else{
    const duration = document.getElementById("input_duration").value - 0;
    if(gpx_data[0]){
      const dist = gpx_data[0].coords.slice(-1)[0].dist;
      const speed = 0.001 * dist / duration;
      return 1e-8 * Math.floor(1e8 * speed);
    }else{
      return 0;
    }
  }
}

/**
 * ルート上の天候情報を取得する
 */
function getRouteWeatherData(){
  const speed = getTargetSpeed();
  
  if(gpx_data.length === 0){
    return;
  }
  
  weather_points.length = 0;
  
  for(const gpx of gpx_data){
    let threshold = 0.0;
    for(const c of gpx.coords){
      if(c.dist >= threshold){
        weather_points.push(c);
        
        threshold += speed * 1000;
      }
    }
  }
  
  showLoader();
  weather_data.fetchWeatherData(weather_points).then(() => {
    // スタート時刻として可能な時刻をselectに追加
    const duration = Math.floor(0.001 * gpx_data[0].coords[gpx_data[0].coords.length - 1].dist / speed);
    const prev_start_time =  document.getElementById("select_start_datetime").value - 0;
    //console.log(prev_start_time);
    //console.log(weather_data.listWeatherDateTime(weather_points[0])[0]);
    //console.log(weather_data.listWeatherDateTime(weather_points.slice(-1)[0]).slice(-1)[0]);
    
    const buf = [];
    const now = Date.now();
    let selected_flag = false;
    for(const t of weather_data.listWeatherDateTime(weather_points[0])){
      const time = new Date(t);
      let selected = "";
      
      if((prev_start_time) && (prev_start_time === t)){
        // 以前のスタート時刻がある場合は以前と同じ時刻を選択
        selected = "selected";
        selected_flag = true;
      }else if((time > now) && !selected_flag){
        // 以前のスタート時刻がない場合は現在時刻以降の最も速い時刻
        selected = "selected";
        selected_flag = true;
      }
      
      const time_formated = time.getFullYear() + "/" + ("0" + (time.getMonth() + 1)).slice(-2) + "/" + ("0" + time.getDate()).slice(-2) + " (" + 
        ("日月火水木金土".split(""))[time.getDay()] + ") " + ("0" + time.getHours()).slice(-2) + ":" + ("0" + time.getMinutes()).slice(-2);
      buf.push(`<option value="${t}" ${selected}>${time_formated}</option>`);
    }
    
    const ele_start_datetime = document.getElementById("select_start_datetime");
    ele_start_datetime.innerHTML = buf.join("\n");
    
    // 地図に表示
    showWeatherData();
    hideLoader();
  });
}

/**
 * 気象データを表示(地図 + グラフ)
 */
function showWeatherData(){
  const speed = getTargetSpeed();
  
  if(gpx_data.length === 0){
    return;
  }
  if(weather_points.length === 0){
    return;
  }
  
  const start_time =  document.getElementById("select_start_datetime").value - 0;
  
  const graph_data = {
    temperature: [],
    windspeed: [],
    windgusts: [],
    precipitation: [],
    cloudcover: []
  };
  
  googlemap.weather_markers.map(e => e.setMap(null));
  googlemap.weather_markers.length = 0;
  
  googlemap.weather_markers.push(new google.maps.Marker({
    position: gpx_data[0].coords[0],
    icon: {
        path: google.maps.SymbolPath.CIRCLE,
        strokeColor: "#fff",
        strokeWeight: 3,
        fillColor: "#0f0",
        fillOpacity: 1,
        scale: 10
    },
    map: googlemap.map
  }));
  googlemap.weather_markers.push(new google.maps.Marker({
    position: gpx_data[0].coords.slice(-1)[0],
    icon: {
        path: google.maps.SymbolPath.CIRCLE,
        strokeColor: "#fff",
        strokeWeight: 3,
        fillColor: "#f00",
        fillOpacity: 1,
        scale: 10
    },
    zIndex: 100,
    map: googlemap.map
  }));

  for(const p of weather_points){
    const data = weather_data.getWeatherData(p, start_time + 3600 * (p.dist / speed));
    //console.log(p);
    //console.log(data);
    
    if(data){
      googlemap.weather_markers.push(new google.maps.Marker({
        map: googlemap.map,
        position: p,
        icon: {
          path: "M -3,6 0,10 3,6 M 0,10 0,-10",
          anchor: new google.maps.Point(0, 10),
          strokeColor: "#000",
          strokeWeight: 3,
          rotation: data.winddirection_10m,
          scale: data.windspeed_10m * 0.5 // 長さで風速を表示
        },
        zIndex: 200,
        title: (new Date(data.time)).toLocaleString() + ": " + data.windspeed_10m.toFixed(1) + "m/s"
      }));
      
      const x = (new Date(data.time)).toISOString();
      graph_data.temperature.push({
        x: x,
        y: data.temperature_2m
      });
      graph_data.windspeed.push({
        x: x,
        y: data.windspeed_10m
      });
      graph_data.windgusts.push({
        x: x,
        y: data.windgusts_10m
      });
      graph_data.precipitation.push({
        x: x,
        y: data.precipitation
      });
      graph_data.cloudcover.push({
        x: x,
        y: data.cloudcover
      });

    }else{
      const x = (new Date(start_time + 3600 * (p.dist / speed))).toISOString();
      graph_data.temperature.push({ x: x, y: null });
      graph_data.windspeed.push({ x: x, y: null });
      graph_data.windgusts.push({ x: x, y: null });
      graph_data.precipitation.push({ x: x, y: null });
      graph_data.cloudcover.push({ x: x, y: null });
    }
  }
  
  const xopts = {
    type: "time",
    time: {
      unit: "hour",
      tooltipFormat: "MM/DD HH:mm",
      displayFormats: {
        hour: "HH:mm"//"MM/DD HH:mm"
      }
    },
    ticks: {
//      autoSkip: false,
      maxRotation: 90,
      minRotation: 90
    }
  };
  
  if(googlemap.graph_position_marker){
    googlemap.graph_position_marker.setMap(null);
  }
  googlemap.graph_position_marker = new google.maps.Marker({
    position: weather_points[0],
    icon: {
      path: google.maps.SymbolPath.CIRCLE,
      scale: 6,// 0.5 * options.strokeWeight + 4,
      fillColor: "#fff",//options.strokeColor,
      fillOpacity: 1,
      strokeColor: "#f00",//options.strokeColor,
      strokeOpacity: 1,
      strokeWeight: 1
    },
    zIndex: 150,
    map: googlemap.map
  });
  googlemap.graph_position_marker.setVisible(false);
  
  if(googlemap.graph_info_window){
    googlemap.graph_info_window.setMap(null);
  }
  googlemap.graph_info_window = new google.maps.InfoWindow({
    content: ""
  });
  
  // グラフの上をマウスが動いたとき、当該場所のマーカーを地図に表示
  const hover = function(evt, item, legend){
    if(item && item.length){
      const index = item[0].index;
      const prev_position = googlemap.graph_position_marker.getPosition();
      
      if((prev_position.lng() !== weather_points[index].lng) || (prev_position.lat() !== weather_points[index].lat)){
        googlemap.graph_position_marker.setPosition(weather_points[index]);
        
        googlemap.graph_info_window.setContent([
          "<table>",
          "<tr><td>時刻</td><td>" + (new Date(graph_data.temperature[index].x)).toLocaleString(),
          "<tr><td>気温</td><td>" + graph_data.temperature[index].y + " ℃" + "</td></tr>",
          "<tr><td>風速</td><td>" + graph_data.windspeed[index].y + " m/s" + "</td></tr>",
          "<tr><td>瞬間風速</td><td>" + graph_data.windgusts[index].y + " m/s" + "</td></tr>",
          "<tr><td>降水量</td><td>" + graph_data.precipitation[index].y + " mm" + "</td></tr>",
          "<tr><td>雲量</td><td>" + graph_data.cloudcover[index].y + " %" + "</td></tr>",
          "</table>",
        ].join(""));
        /*googlemap.graph_info_window.open({
          anchor: googlemap.graph_position_marker,
          map: googlemap.map,
          shouldFocus: false
        });*/
      }
      if(!googlemap.graph_position_marker.getVisible()){
        googlemap.graph_position_marker.setVisible(true);
      }
      
      // ツールチップを同期させて表示
      for(const chart of Object.values(charts)){
        chart.tooltip.setActiveElements(chart.data.datasets.map((e, i) => ({
          datasetIndex: i,
          index: index
        })));
        chart.update();
      }
    }
  };
  const mouseout = function(evt){
    googlemap.graph_position_marker.setVisible(false);
    googlemap.graph_info_window.close();
    
    for(const chart of Object.values(charts)){
      chart.tooltip.setActiveElements([]);
      chart.update();
    }
  }
  
  if(charts.temperature){
    charts.temperature.destroy();
  }
  charts.temperature = new Chart(document.getElementById("canvas_temperature"), {
    type: "line",
    data: {
      datasets: [{
        label: "気温 [℃]",
        lineTension: 0,
        borderColor: "#383",
        fill: true,
        backgroundColor: "#7c7",
        pointRadius: 0,
        data: graph_data.temperature
      }]
    },
    options: {
      scales: {
        x: xopts
      },
      interaction: {
        intersect: false,
        mode: "index",
        axis: "x"
      },
      animation: false,
      maintainAspectRatio: false,
      onHover: hover
    }
  });
  document.getElementById("canvas_temperature").onmouseout = mouseout;
  
  if(charts.wind){
    charts.wind.destroy();
  }
  charts.wind = new Chart(document.getElementById("canvas_windspeed"), {
    type: "line",
    data: {
      datasets: [{
        label: "風速 [m/s]",
        lineTension: 0,
        borderColor: "#f00",
        fill: true,
        backgroundColor: "#f88",
        pointRadius: 0,
        data: graph_data.windspeed
      }, {
        label: "瞬間風速 [m/s]",
        lineTension: 0,
        borderColor: "#55f",
        fill: true,
        backgroundColor: "#ddf",
        pointRadius: 0,
        data: graph_data.windgusts
      }]
    },
    options: {
      scales: {
        x: xopts,
        y: {
          suggestedMax: 20,
          min: 0
        }
      },
      interaction: {
        intersect: false,
        mode: "index",
        axis: "x"
      },
      animation: false,
      maintainAspectRatio: false,
      onHover: hover
    }
  });
  document.getElementById("canvas_windspeed").onmouseout = mouseout;
  
  if(charts.precipitation){
    charts.precipitation.destroy();
  }
  charts.precipitation = new Chart(document.getElementById("canvas_precipitation"), {
    data: {
      datasets: [{
        type: "bar",
        yAxisID: "y1",
        label: "降水量 [mm]",
        lineTension: 0,
        borderColor: "#00f",
        fill: true,
        backgroundColor: "#88f",
        data: graph_data.precipitation
      }, {
        type: "line",
        yAxisID: "y2",
        label: "雲量 [%]",
        lineTension: 0,
        borderColor: "#333",
        fill: true,
        backgroundColor: "#888",
        pointRadius: 0,
        data: graph_data.cloudcover
      }]
    },
    options: {
      scales: {
        x: xopts,
        y1: {
          type: "linear",
          position: "left",
          //max: 30,
          suggestedMax: 10,
          min: 0
        },
        y2: {
          type: "linear", 
          position: "right",
          max: 100,
          min: 0
        }
      },
      interaction: {
        intersect: false,
        mode: "index",
        axis: "x"
      },
      animation: false,
      maintainAspectRatio: false,
      onHover: hover
    }
  });
  document.getElementById("canvas_precipitation").onmouseout = mouseout;
}

window.addEventListener("DOMContentLoaded", function(){
  // GPX読み込み
  document.getElementById("file_gpx").addEventListener("change", async function(evt){
    try{
      if(evt.target.files.length){
        showLoader();

        gpx_data.length = 0;
        
        for(let i = 0; i < evt.target.files.length; i++){
          console.log(evt.target.files[i]);
          const gpx = await readXML(evt.target.files[i]);
          gpx_data.push(parseGPX(gpx, evt.target.files[i].name));
        }
        
        fitBounds();
        showRoutes();
        getRouteWeatherData();
      }
    }catch(err){
      console.error(err);

    }finally{
      hideLoader();
      
    }
  });
  
  // スタート日時変更
  document.getElementById("select_start_datetime").addEventListener("change", showWeatherData);
  
  const change_radio_select = function(evt){
    if(document.getElementById("radio_speed").checked){
      document.getElementById("radio_speed").checked = true;
      document.getElementById("input_speed").disabled = false;
      document.getElementById("input_duration").disabled = true;
      document.getElementById("input_speed").dispatchEvent(new Event("change"));
    }else{
      document.getElementById("radio_duration").checked = true;
      document.getElementById("input_speed").disabled = true;
      document.getElementById("input_duration").disabled = false;
      document.getElementById("input_duration").dispatchEvent(new Event("change"));
    }
  };
  
  // 速度変更
  document.getElementById("radio_speed").addEventListener("change", change_radio_select);
  document.getElementById("input_speed").addEventListener("change", function(evt){
    const speed = document.getElementById("input_speed").value - 0;
    if(gpx_data[0]){
      const dist = gpx_data[0].coords.slice(-1)[0].dist;
      const duration = 0.001 * dist / speed;
      document.getElementById("input_duration").value = (0.01 * Math.floor(100 * duration)).toFixed(2);
    }
    
    getRouteWeatherData();
  });
  
  // 目標時間変更
  document.getElementById("radio_duration").addEventListener("change", change_radio_select);
  document.getElementById("input_duration").addEventListener("change", function(evt){
    const duration = document.getElementById("input_duration").value - 0;
    if(gpx_data[0]){
      const dist = gpx_data[0].coords.slice(-1)[0].dist;
      const speed = 0.001 * dist / duration;
      document.getElementById("input_speed").value = (0.01 * Math.floor(100 * speed)).toFixed(2);
    }
    
    getRouteWeatherData();
  });
  
  document.getElementById("flexbox_reset").addEventListener("click", async function(evt){
    document.getElementById("file_gpx").value = "";
    gpx_data.length = 0;
    googlemap.weather_markers.map(e => e.setMap(null));
    googlemap.weather_markers.length = 0;
    
    for(let i in charts){
      if(charts[i]){
        charts[i].destroy();
      }
      charts[i] = null;
    }
    document.getElementById("select_start_datetime").innerHTML = "";
    document.getElementById("input_speed").value = "15";
    
    showRoutes();
  });
  
  // フルスクリーンボタン
  document.getElementById("flexbox_fullscreen").addEventListener("click", function(evt){
    if(document.fullscreenElement){
      document.exitFullscreen();
    }else{
      document.body.requestFullscreen();
    }
  });
  
  // iframeで読み込まれているときはリンクを表示しない
  if(window !== window.parent){
    document.getElementById("flexbox_link").style.display = "none"
  }
});

// 戻るボタンを押されたときにフォームの値が残っているとき
window.addEventListener("pageshow", function(evt){
  console.log("pageshow");
  console.log(evt);
  console.log(document.getElementById("select_start_datetime").value);
  console.log(document.getElementById("radio_speed").checked);
  console.log(document.getElementById("radio_duration").checked);
  console.log(document.getElementById("input_speed").value);
  console.log(document.getElementById("input_duration").value);
  
  document.getElementById("radio_speed").dispatchEvent(new Event("change"));
  //document.getElementById("input_speed").dispatchEvent(new Event("change"));
  document.getElementById("file_gpx").dispatchEvent(new Event("change"));
});

/**
 * Google Maps JavaScript API Initialize Callback
 */
function initMap(){
  googlemap.map = new google.maps.Map(document.getElementById("map_canvas"), {
    zoom: 6,
    mapTypeId: google.maps.MapTypeId.ROADMAP,
    center: new google.maps.LatLng(35.681382, 139.766084),
    fullscreenControl: false,
    gestureHandling: "greedy"
  });
  
  hideLoader();
}

function hideLoader(){
  document.getElementById("loader_bg").style.display = "none";
}

function showLoader(){
  document.getElementById("loader_bg").style.display = "block";
}

// ドラッグドロップ対応
window.addEventListener("DOMContentLoaded", function(){
  function addDropArea(droparea, target){
    const overlay = document.createElement("div");
    
    overlay.style.position = "absolute";
    overlay.style.top = "0";
    overlay.style.left = "0";
    overlay.style.width = "100%";
    overlay.style.height = "100%";
    overlay.style.zIndex = "9998";
    overlay.style.backgroundColor = "#ddd";
    overlay.style.opacity = "0.5";
    overlay.style.display = "none";
    
    droparea.appendChild(overlay);
    droparea.addEventListener("dragover", function(e){
      e.stopPropagation();
      e.preventDefault();
      overlay.style.display = "block";
    }, false);
    overlay.addEventListener("dragleave", function(e){
      e.stopPropagation();
      e.preventDefault();
      overlay.style.display = "none";
    }, false);
    overlay.addEventListener("drop", function(e){
      e.stopPropagation();
      e.preventDefault();
      overlay.style.display = "none";
      
      target.files = e.dataTransfer.files;

      target.dispatchEvent(new Event("change"));
    }, false);
  }
  
  addDropArea(document.body, document.getElementById("file_gpx"));
});

// ドラッグドロップ失敗時にファイルがダウンロードされるのを防止
window.addEventListener("dragover", function(e){
  e = e || event;
  e.preventDefault();
}, false);
window.addEventListener("drop", function(e){
  e = e || event;
  e.preventDefault();
}, false);

/**
 * L1, L2の2層のキャッシュ
 * @param {string} cache_name          Cache APIで使用する名前(cacheName)
 * @param {function} parser            responseを受け取ってキャッシュに保存する内容を返すPromiseを返すコールバック関数
 * @param {number} l1_cache_size       L1キャッシュに保持するURL件数
 * @param {number} l2_cache_expiration L2キャッシュの有効期限(ミリ秒)
 */
function LayeredCache(cache_name, parser, l1_cache_size = 1000, cache_expiration = 30 * 86400 * 1000){
  const HEADER_EXPIRATION = "_expire_on";
  const l1_cache = new Map();
  let l2_cache = {
    match: async function(){ return (void 0);},
    put:  async function(){ return (void 0);},
    delete:  async function(){ return true;}
  }; // ダミーのCacheオブジェクトを入れておく
  let prepared = false;
  
  if(window.caches){
    caches.open(cache_name).then((cs) => {
      l2_cache = cs;
      prepared = true;
    }).catch((e) => {
      console.error("Cache API ERROR");
      prepared = true;
    });
  }else{
    console.error("Cache API Not Supported");
    prepared = true;
  }
  
  /**
   * 指定したURLのデータをparser関数で処理した結果を返す。
   * L1にあればL1キャッシュからparserで処理済みの結果を返し、
   * 有効期限内のL2キャッシュ(Cache API)があれば、再度parser関数で処理して返す。
   * @param {string} url
   * @return {Promise}
   */
  this.fetch = async function(url){
    let data = null;
    let fetch_flag = false;
    let l1_update_flag = false;
    const now = Date.now();
    let expiration = now + cache_expiration;

    if(!prepared){
      // Cache APIの準備ができていなければ待機
      await new Promise((resolve, reject) => {
        const f = function(){
          if(prepared){
            resolve();
          }else{
            setTimeout(f, 10);
          }
        };
        setTimeout(f, 10);
      });
    }
    
    if(l1_cache.has(url)){
      // L1キャッシュにヒット
      const v = l1_cache.get(url);

      if(now > v.expire_on){
        // L1キャッシュで期限切れ
        fetch_flag = true;
      }else{
        // L1キャッシュの末尾に移動(LRU)
        l1_cache.delete(url);
        l1_cache.set(url, v);
        data = v.data;
      }

    }else{
      const response = await l2_cache.match(url);
      
      if((response === undefined)
        || response.headers.get(HEADER_EXPIRATION) === null
        || (now > Number.parseInt(response.headers.get(HEADER_EXPIRATION)))){
        // L2キャッシュにない場合、またはL2キャッシュが期限切れの場合
        fetch_flag = true;
      }else{
        data = await parser(response);
        expiration = Number.parseInt(response.headers.get(HEADER_EXPIRATION));
        
        l1_update_flag = true;
      }
    }
    
    if(fetch_flag){
      // 通信して取得する
      const response = await fetch(url);
      
      const copy = response.clone();
      const headers = new Headers(copy.headers);
      headers.append(HEADER_EXPIRATION, expiration);
      
      const body = await copy.blob();
      
      await l2_cache.put(url, new Response(body, {
        status: copy.status,
        statusText: copy.statusText,
        headers: headers
      }));
      
      data = await parser(response);
      l1_update_flag = true;
    }
    
    if(l1_update_flag){
      // L1キャッシュの末尾に保存
      l1_cache.set(url, {
        data: data,
        expire_on: expiration
      });
      if(l1_cache.length > l1_cache_size){
        l1_cache.delete(l1_cache.keys().next().value);
      }
    }
    
    return data;
  };
  
  return this;
}

</script>
<style>
* { margin: 0; padding: 0}
html, body {
  width: 100%;
  height: 100%;
  font-family: sans-serif;
}
#wrapper {
  width: 100%;
  height: 100%;
  overflow: hidden;
  
  display: flex;
  flex-direction: column;
}
#top_panel {
  width: 100%;
  flex: none;
  overflow: hidden;
  background-color: #eee;
  display: flex;
  flex-wrap: wrap;
  line-height: 1em;
}
#flexbox_gpx {
  position: relative;
  flex: 5 5;
  height: 48px;
  margin: 1px;
  border: 1px solid gray;
  border-radius: 3px;
  padding: 3px;
  box-sizing: border-box;
  line-height: 100%;
  
  display:flex;
  flex-direction: row;
  justify-content: center;
  align-items: center;
}

#flexbox_gpx label, #flexbox_start_datetime label/*, #flexbox_target_designation label*/ {
  display: block;
  white-space: nowrap;
  width: 100%;
  line-height: 16px;
}
input[type=file] {
  /*background: #fff;*/
  width: 100%;
}
#flexbox_start_datetime {
  flex: 0 0 160px;
  height: 48px;
  margin: 1px;
  border: 1px solid gray;
  border-radius: 3px;
  padding: 3px;
  box-sizing: border-box;
  
  display:flex;
  flex-direction: row;
  justify-content: center;
  align-items: center;
}
#select_start_datetime {
  width: 100%;
}
#flexbox_target_designation {
  flex: 0 0 240px;
  height: 48px;
  margin: 1px;
  border: 1px solid gray;
  border-radius: 3px;
  padding: 3px;
  box-sizing: border-box;
  
  display:flex;
  flex-direction: row;
  justify-content: center;
  align-items: center;
}
#flexbox_target_designation > div {
  flex: 0 0 50%;
}
#flexbox_target_designation input[type=number] {
  width: 4em;
}

#flexbox_reset {
  flex: 0 0 50px;
  height: 48px;
  margin: 1px;
  border: 1px solid gray;
  border-radius: 3px;
  padding: 3px;
  box-sizing: border-box;
  font-size: 14px;
  vertical-align: middle;
  line-height: 40px;
  text-align: center;
  
  display: none;
  /*display:flex;*/
  flex-direction: row;
  justify-content: center;
  align-items: center;
}
#flexbox_gpx:hover, #droparea_target:hover, #flexbox_reset:hover {
  background-color: #ddd;
}
#flexbox_fullscreen {
  display: none;
  flex: 0 0 40px;
  height: 48px;
  padding: 3px;
  box-sizing: border-box;
  vertical-align: middle;
  line-height: 40px;
  text-align: center;
}
#flexbox_fullscreen img {
  height: 24px;
  margin: 11px auto;
  cursor: pointer;
}
#flexbox_link {
  display: none;
  flex: 0 0 40px;
  height: 48px;
  padding: 3px;
  box-sizing: border-box;
  vertical-align: middle;
  line-height: 40px;
  text-align: center;
}
#flexbox_link a {
  display: block;
  height: 32px;
  margin: 7px auto;
}
@media screen and (max-width: 800px){
  .omittable{ display: none }
}

#map_panel {
  flex: 1;
  display: flex;
}
#map_canvas {
  flex: 1;
}
#chart_panel {
  flex: 0 1 25%;
  display: flex;
  flex-direction: column;
}
#chart_panel > div {
  flex: 1;
  display: flex;
  justify-content: center;
  align-items: center;
  padding: 5px;
  background-color: #f8f8f8;
}

#loader_bg {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(1, 1, 1, 0.25);
  z-index: 9999;
}
#loader {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  padding: 10px;
  border-radius: 30px;
  background: #ddd;
}

#dist_info {
  position: absolute;
  display: none;
  top: 0;
  left: 0;
  z-index: 9999;
  padding: 3px;
  background-color: #eee;
  border-radius: 3px;
  border-width: 1px;
  border-color: #000;
  border-style: solid;
}

@media screen and (orientation: portrait) {
  #map_panel {
    flex-direction: column;
  }
  #chart_panel {
    /*flex-direction: row;*/
    flex: 0 1 50%;
    overflow-y: auto;
  }
  #chart_panel > div {
    /*width: 30%;*/
  }
}

</style>
</head>
<body>
<div id="wrapper">
 <div id="top_panel">
  <div id="flexbox_gpx"><label accesskey="o">GPXファイル<br><input type="file" id="file_gpx" accept=".gpx"></label></div>
  <div id="flexbox_start_datetime"><label accesskey="s">スタート日時<br><select id="select_start_datetime"></select></label></div>
  <div id="flexbox_target_designation">
   <div><label><input id="radio_speed" type="radio" name="designate_method" value="speed" checked>速度で指定<br><input id="input_speed" value="15" type="number" min="10" max="40"> km/h</label></div>
   <div><label><input id="radio_duration" type="radio" name="designate_method" value="duration">時間で指定<br><input id="input_duration" value="24" type="number" min="1" max="300"> h</label></div>
  </div>
  <div id="flexbox_reset">Clear</div>
  <div id="flexbox_fullscreen"><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 513.32 513.32' xml:space='preserve'%3E%3Cpath d='M177.523 305.853 42.777 440.6v-98.387H0V513.32h171.107v-42.777H74.859l134.746-134.746z'/%3E%3Cpath d='M470.543 440.6 72.72 42.777h98.387V0H0v171.107h42.777V72.72L440.6 470.543h-98.387v42.777H513.32V342.213h-42.777z'/%3E%3Cpath d='M342.213 0v42.777h100.526L307.992 177.523l29.943 29.944L470.543 74.859v96.248h42.777V0z'/%3E%3C/svg%3E" width="24" height="24" title="フルスクリーン"></div>
  <div id="flexbox_link"><a href="https://www.330k.info/software/gpx-weather/" target="_blank" title="説明ページを開きます"><img src="data:image/svg+xml,%3Csvg viewBox='0 0 32 32' xmlns='http://www.w3.org/2000/svg'%3E%3Cg data-name='Layer 2'%3E%3Cpath d='M16 12a2 2 0 1 1 2-2 2 2 0 0 1-2 2Zm0-2Z'/%3E%3Cpath d='M16 29a13 13 0 1 1 13-13 13 13 0 0 1-13 13Zm0-24a11 11 0 1 0 11 11A11 11 0 0 0 16 5Z'/%3E%3Cpath d='M16 24a2 2 0 0 1-2-2v-6a2 2 0 0 1 4 0v6a2 2 0 0 1-2 2Zm0-8Z'/%3E%3C/g%3E%3Cpath fill='none' d='M0 0h32v32H0z'/%3E%3C/svg%3E" width="32" height="32"></a></div>
 </div>
 <div id="map_panel">
  <div id="map_canvas"></div>
  <div id="chart_panel">
   <div id="chart_temperature"><canvas id="canvas_temperature"></canvas></div>
   <div id="chart_windspeed"><canvas id="canvas_windspeed"></canvas></div>
   <div id="chart_precipitation"><canvas id="canvas_precipitation"></canvas></div>
  </div>
 </div>
</div>
<div id="dist_info"></div>
<div id="loader_bg">
<div id="loader">
<img src="data:image/svg+xml,%3Csvg width='32' height='32' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100' preserveAspectRatio='xMidYMid' class='uil-spin'%3E%3Cpath fill='none' class='bk' d='M0 0h100v100H0z'/%3E%3Cg transform='translate(84 50)'%3E%3Ccircle r='8'%3E%3Canimate attributeName='opacity' from='1' to='.1' begin='0s' dur='1s' repeatCount='indefinite'/%3E%3CanimateTransform attributeName='transform' type='scale' from='1.5' to='1' begin='0s' dur='1s' repeatCount='indefinite'/%3E%3C/circle%3E%3C/g%3E%3Cg transform='rotate(45 -52.355 126.397)'%3E%3Ccircle r='8'%3E%3Canimate attributeName='opacity' from='1' to='.1' begin='0.12s' dur='1s' repeatCount='indefinite'/%3E%3CanimateTransform attributeName='transform' type='scale' from='1.5' to='1' begin='0.12s' dur='1s' repeatCount='indefinite'/%3E%3C/circle%3E%3C/g%3E%3Cg transform='rotate(90 -17 67)'%3E%3Ccircle r='8'%3E%3Canimate attributeName='opacity' from='1' to='.1' begin='0.25s' dur='1s' repeatCount='indefinite'/%3E%3CanimateTransform attributeName='transform' type='scale' from='1.5' to='1' begin='0.25s' dur='1s' repeatCount='indefinite'/%3E%3C/circle%3E%3C/g%3E%3Cg transform='rotate(135 -2.355 42.397)'%3E%3Ccircle r='8'%3E%3Canimate attributeName='opacity' from='1' to='.1' begin='0.37s' dur='1s' repeatCount='indefinite'/%3E%3CanimateTransform attributeName='transform' type='scale' from='1.5' to='1' begin='0.37s' dur='1s' repeatCount='indefinite'/%3E%3C/circle%3E%3C/g%3E%3Cg transform='rotate(180 8 25)'%3E%3Ccircle r='8'%3E%3Canimate attributeName='opacity' from='1' to='.1' begin='0.5s' dur='1s' repeatCount='indefinite'/%3E%3CanimateTransform attributeName='transform' type='scale' from='1.5' to='1' begin='0.5s' dur='1s' repeatCount='indefinite'/%3E%3C/circle%3E%3C/g%3E%3Cg transform='rotate(-135 18.355 7.603)'%3E%3Ccircle r='8'%3E%3Canimate attributeName='opacity' from='1' to='.1' begin='0.62s' dur='1s' repeatCount='indefinite'/%3E%3CanimateTransform attributeName='transform' type='scale' from='1.5' to='1' begin='0.62s' dur='1s' repeatCount='indefinite'/%3E%3C/circle%3E%3C/g%3E%3Cg transform='rotate(-90 33 -17)'%3E%3Ccircle r='8'%3E%3Canimate attributeName='opacity' from='1' to='.1' begin='0.75s' dur='1s' repeatCount='indefinite'/%3E%3CanimateTransform attributeName='transform' type='scale' from='1.5' to='1' begin='0.75s' dur='1s' repeatCount='indefinite'/%3E%3C/circle%3E%3C/g%3E%3Cg transform='rotate(-45 68.355 -76.397)'%3E%3Ccircle r='8'%3E%3Canimate attributeName='opacity' from='1' to='.1' begin='0.87s' dur='1s' repeatCount='indefinite'/%3E%3CanimateTransform attributeName='transform' type='scale' from='1.5' to='1' begin='0.87s' dur='1s' repeatCount='indefinite'/%3E%3C/circle%3E%3C/g%3E%3C/svg%3E" width="128" height="128">
</div>
</div>
</body>
</html>
